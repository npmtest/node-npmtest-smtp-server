{"/home/travis/build/npmtest/node-npmtest-smtp-server/test.js":"/* istanbul instrument in package npmtest_smtp_server */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-smtp-server/lib.npmtest_smtp_server.js":"/* istanbul instrument in package npmtest_smtp_server */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_smtp_server = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_smtp_server = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-smtp-server/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-smtp-server && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_smtp_server */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_smtp_server\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_smtp_server.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_smtp_server.rollup.js'] =\n            local.assetsDict['/assets.npmtest_smtp_server.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_smtp_server.__dirname + '/lib.npmtest_smtp_server.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-smtp-server/node_modules/smtp-server/lib/smtp-server.js":"'use strict';\n\nconst net = require('net');\nconst tls = require('tls');\nconst SMTPConnection = require('./smtp-connection').SMTPConnection;\nconst tlsOptions = require('./tls-options');\nconst EventEmitter = require('events');\nconst shared = require('nodemailer/lib/shared');\n\nconst CLOSE_TIMEOUT = 30 * 1000; // how much to wait until pending connections are terminated\n\n/**\n * Creates a SMTP server instance.\n *\n * @constructor\n * @param {Object} options Connection and SMTP optionsž\n */\nclass SMTPServer extends EventEmitter {\n    constructor(options) {\n        super();\n\n        this.options = options || {};\n\n        this.secureContext = new Map();\n        this.secureContext.set('default', tls.createSecureContext(tlsOptions(this.options)));\n\n        let ctxMap = this.options.sniOptions || {};\n        if (typeof ctxMap.get === 'function') {\n            ctxMap.forEach((ctx, servername) => {\n                this.secureContext.set(servername.toLowerCase().trim(), tls.createSecureContext(tlsOptions(ctx)));\n            });\n        } else {\n            Object.keys(ctxMap).forEach(servername => {\n                this.secureContext.set(servername.toLowerCase().trim(), tls.createSecureContext(tlsOptions(ctxMap[servername])));\n            });\n        }\n\n        // apply TLS defaults if needed, only if there is not SNICallback.\n        if (this.options.secure && typeof this.options.SNICallback !== 'function') {\n            this.options = tlsOptions(this.options);\n            this.options.SNICallback = (servername, cb) => {\n                cb(null, this.secureContext.get(servername.toLowerCase().trim()) || this.secureContext.get('default'));\n            };\n        }\n\n        // setup disabled commands list\n        this.options.disabledCommands = [].concat(this.options.disabledCommands || [])\n            .map(command => (command || '').toString().toUpperCase().trim());\n\n        // setup allowed auth methods\n        this.options.authMethods = [].concat(this.options.authMethods || [])\n            .map(method => (method || '').toString().toUpperCase().trim());\n\n        if (!this.options.authMethods.length) {\n            this.options.authMethods = ['LOGIN', 'PLAIN'];\n        }\n\n        this.logger = shared.getLogger(this.options, {\n            component: this.options.component || 'smtp-server'\n        });\n\n        // apply shorthand handlers\n        ['onConnect', 'onAuth', 'onMailFrom', 'onRcptTo', 'onData', 'onClose'].forEach(handler => {\n            if (typeof this.options[handler] === 'function') {\n                this[handler] = this.options[handler];\n            }\n        });\n\n        /**\n         * Timeout after close has been called until pending connections are forcibly closed\n         */\n        this._closeTimeout = false;\n\n        /**\n         * A set of all currently open connections\n         */\n        this.connections = new Set();\n\n        // setup server listener and connection handler\n        this.server = (this.options.secure ? tls : net)\n            .createServer(this.options, socket => this.connect(socket));\n\n        // ensure _sharedCreds, fixes an issue in node v4+ where STARTTLS fails because _sharedCreds does not exist\n        this.server._sharedCreds = this.server._sharedCreds || this.secureContext.get('default');\n\n        this._setListeners();\n    }\n\n    connect(socket) {\n        let connection = new SMTPConnection(this, socket);\n        this.connections.add(connection);\n        connection.on('error', err => this._onError(err));\n        connection.on('connect', data => this._onClientConnect(data));\n        connection.init();\n    }\n\n    /**\n     * Start listening on selected port and interface\n     */\n    listen(...args) {\n        this.server.listen(...args);\n    }\n\n    /**\n     * Closes the server\n     *\n     * @param {Function} callback Callback to run once the server is fully closed\n     */\n    close(callback) {\n        let connections = this.connections.size;\n        let timeout = this.options.closeTimeout || CLOSE_TIMEOUT;\n\n        // stop accepting new connections\n        this.server.close(() => {\n            clearTimeout(this._closeTimeout);\n            if (typeof callback === 'function') {\n                return callback();\n            }\n        });\n\n        // close active connections\n        if (connections) {\n            this.logger.info({\n                tnx: 'close'\n            }, 'Server closing with %s pending connection%s, waiting %s seconds before terminating', connections, connections !== 1 ? 's' : '', timeout / 1000);\n        }\n\n        this._closeTimeout = setTimeout(() => {\n            connections = this.connections.size;\n            if (connections) {\n                this.logger.info({\n                    tnx: 'close'\n                }, 'Closing %s pending connection%s to close the server', connections, connections !== 1 ? 's' : '');\n\n                this.connections.forEach(connection => {\n                    connection.send(421, 'Server shutting down');\n                    connection.close();\n                });\n            }\n        }, timeout);\n    }\n\n    /**\n     * Authentication handler. Override this\n     *\n     * @param {Object} auth Authentication options\n     * @param {Function} callback Callback to run once the user is authenticated\n     */\n    onAuth(auth, session, callback) {\n        if (auth.method === 'XOAUTH2') {\n            return callback(null, {\n                data: {\n                    status: '401',\n                    schemes: 'bearer mac',\n                    scope: 'https://mail.google.com/'\n                }\n            });\n        }\n\n        return callback(null, {\n            message: 'Authentication not implemented'\n        });\n    }\n\n    onConnect(session, callback) {\n        setImmediate(callback);\n    }\n\n    onMailFrom(address, session, callback) {\n        setImmediate(callback);\n    }\n\n    onRcptTo(address, session, callback) {\n        setImmediate(callback);\n    }\n\n    onData(stream, session, callback) {\n        let chunklen = 0;\n\n        stream.on('data', chunk => {\n            chunklen += chunk.length;\n        });\n\n        stream.on('end', () => {\n            this.logger.info({\n                tnx: 'message',\n                size: chunklen\n            }, '<received %s bytes>', chunklen);\n            callback();\n        });\n    }\n\n    onClose( /* session */ ) {\n        // do nothing\n    }\n\n    // PRIVATE METHODS\n\n    /**\n     * Setup server event handlers\n     */\n    _setListeners() {\n        this.server.on('listening', () => this._onListening());\n        this.server.on('close', () => this._onClose());\n        this.server.on('error', err => this._onError(err));\n    }\n\n    /**\n     * Called when server started listening\n     *\n     * @event\n     */\n    _onListening() {\n        let address = this.server.address();\n        this.logger.info(\n            //\n            {\n                tnx: 'listen',\n                host: address.address,\n                port: address.port,\n                secure: !!this.options.secure,\n                protocol: this.options.lmtp ? 'LMTP' : 'SMTP'\n            },\n            '%s%s Server listening on %s:%s',\n            this.options.secure ? 'Secure ' : '',\n            this.options.lmtp ? 'LMTP' : 'SMTP',\n            address.family === 'IPv4' ? address.address : '[' + address.address + ']',\n            address.port);\n    }\n\n    /**\n     * Called when server is closed\n     *\n     * @event\n     */\n    _onClose() {\n        this.logger.info({\n            tnx: 'closed'\n        }, (this.options.lmtp ? 'LMTP' : 'SMTP') + ' Server closed');\n        this.emit('close');\n    }\n\n    /**\n     * Called when an error occurs with the server\n     *\n     * @event\n     */\n    _onError(err) {\n        this.emit('error', err);\n    }\n\n    /**\n     * Called when a new connection is established. This might not be the same time the socket is opened\n     *\n     * @event\n     */\n    _onClientConnect(data) {\n        this.emit('connect', data);\n    }\n}\n\n// Expose to the world\nmodule.exports.SMTPServer = SMTPServer;\n","/home/travis/build/npmtest/node-npmtest-smtp-server/node_modules/smtp-server/lib/smtp-connection.js":"'use strict';\n\nconst SMTPStream = require('./smtp-stream').SMTPStream;\nconst dns = require('dns');\nconst tls = require('tls');\nconst net = require('net');\nconst ipv6normalize = require('ipv6-normalize');\nconst sasl = require('./sasl');\nconst crypto = require('crypto');\nconst os = require('os');\nconst punycode = require('punycode');\nconst EventEmitter = require('events');\n\nconst SOCKET_TIMEOUT = 60 * 1000;\n\n/**\n * Creates a handler for new socket\n *\n * @constructor\n * @param {Object} server Server instance\n * @param {Object} socket Socket instance\n */\nclass SMTPConnection extends EventEmitter {\n    constructor(server, socket) {\n        super();\n        // Random session ID, used for logging\n        this._id = crypto.randomBytes(9).toString('base64');\n\n        this._server = server;\n        this._socket = socket;\n\n        // session data (envelope, user etc.)\n        this.session = this.session = {\n            id: this._id\n        };\n\n        // how many messages have been processed\n        this._transactionCounter = 0;\n\n        // Do not allow input from client until initial greeting has been sent\n        this._ready = false;\n\n        // If true then the connection is currently being upgraded to TLS\n        this._upgrading = false;\n\n        // Set handler for incoming command and handler bypass detection by command name\n        this._nextHandler = false;\n\n        // Parser instance for the incoming stream\n        this._parser = new SMTPStream();\n\n        // Set handler for incoming commands\n        this._parser.oncommand = (...args) => this._onCommand(...args);\n\n        // if currently in data mode, this stream gets the content of incoming message\n        this._dataStream = false;\n\n        // If true, then the connection is using TLS\n        this.session.secure = this.secure = !!this._server.options.secure;\n\n        this.tlsOptions = this.secure ? this._socket.getCipher() : false;\n\n        // Store remote address for later usage\n        this.remoteAddress = (this._socket.remoteAddress || '').replace(/^::ffff:/, '');\n        this.remotePort = Number(this._socket.remotePort) || 0;\n\n        // normalize IPv6 addresses\n        if (this.remoteAddress && net.isIPv6(this.remoteAddress)) {\n            this.remoteAddress = ipv6normalize(this.remoteAddress);\n        }\n\n        // Error counter - if too many commands in non-authenticated state are used, then disconnect\n        this._unauthenticatedCommands = 0;\n\n        // Error counter - if too many invalid commands are used, then disconnect\n        this._unrecognizedCommands = 0;\n\n        // Server hostname for the greegins\n        this.name = this._server.options.name || os.hostname();\n\n        // Resolved hostname for remote IP address\n        this.clientHostname = false;\n\n        // The opening SMTP command (HELO, EHLO or LHLO)\n        this.openingCommand = false;\n\n        // The hostname client identifies itself with\n        this.hostNameAppearsAs = false;\n\n        // data passed from XCLIENT command\n        this._xClient = new Map();\n\n        // data passed from XFORWARD command\n        this._xForward = new Map();\n\n        // if true then can emit connection info\n        this._canEmitConnection = true;\n\n        // increment connection count\n        this._closing = false;\n        this._closed = false;\n    }\n\n    /**\n     * Initiates the connection. Checks connection limits and reverse resolves client hostname. The client\n     * is not allowed to send anything before init has finished otherwise 'You talk too soon' error is returned\n     */\n    init() {\n        // Setup event handlers for the socket\n        this._setListeners();\n\n        // Check that connection limit is not exceeded\n        if (this._server.options.maxClients && this._server.connections.size > this._server.options.maxClients) {\n            return this.send(421, this.name + ' Too many connected clients, try again in a moment');\n        }\n\n        if (!this._server.options.useProxy) {\n            // Keep a small delay for detecting early talkers\n            setTimeout(() => this.connectionReady(), 100);\n        }\n    }\n\n    connectionReady(next) {\n\n        // Resolve hostname for the remote IP\n        let reverseCb = (err, hostnames) => {\n            if (err) {\n                // ignore resolve error\n            }\n\n            if (this._closing || this._closed) {\n                return;\n            }\n\n            this.clientHostname = hostnames && hostnames.shift() || '[' + this.remoteAddress + ']';\n\n            this._resetSession();\n\n            this._server.onConnect(this.session, err => {\n                this._server.logger.info({\n                    tnx: 'connection',\n                    cid: this._id,\n                    host: this.remoteAddress,\n                    hostname: this.clientHostname\n                }, 'Connection from %s', this.clientHostname);\n\n                if (err) {\n                    this.send(err.responseCode || 554, err.message);\n                    return this.close();\n                }\n\n                this._ready = true; // Start accepting data from input\n\n                if (!this._server.options.useXClient && !this._server.options.useXForward) {\n                    this.emitConnection();\n                }\n\n                this.send(220, this.name + ' ' + (this._server.options.lmtp ? 'LMTP' : 'ESMTP') + (this._server.options.banner ? ' ' + this._server.options.banner : ''));\n\n                if (typeof next === 'function') {\n                    next();\n                }\n            });\n        };\n\n        // Skip reverse name resolution if disabled.\n        if (this._server.options.disableReverseLookup) {\n            return reverseCb(null, false);\n        }\n\n        try {\n            // dns.reverse throws on invalid input, see https://github.com/nodejs/node/issues/3112\n            dns.reverse(this.remoteAddress.toString(), reverseCb);\n        } catch (E) {\n            reverseCb(E);\n        }\n\n    }\n\n    /**\n     * Send data to socket\n     *\n     * @param {Number} code Response code\n     * @param {String|Array} data If data is Array, send a multi-line response\n     */\n    send(code, data) {\n        let payload;\n\n        if (Array.isArray(data)) {\n            payload = data.map((line, i, arr) => code + (i < arr.length - 1 ? '-' : ' ') + line).join('\\r\\n');\n        } else {\n            payload = [].concat(code || []).concat(data || []).join(' ');\n        }\n\n        if (this._socket && this._socket.writable) {\n            this._socket.write(payload + '\\r\\n');\n            this._server.logger.debug({\n                tnx: 'send',\n                cid: this._id,\n                user: this.session.user && this.session.user.username\n            }, 'S:', payload);\n        }\n\n        if (code === 421) {\n            this.close();\n        }\n    }\n\n    /**\n     * Close socket\n     */\n    close() {\n        if (!this._socket.destroyed && this._socket.writable) {\n            this._socket.end();\n        }\n\n        this._server.connections.delete(this);\n\n        this._closing = true;\n    }\n\n    // PRIVATE METHODS\n\n    /**\n     * Setup socket event handlers\n     */\n    _setListeners() {\n        this._socket.on('close', () => this._onClose());\n        this._socket.on('error', err => this._onError(err));\n        this._socket.setTimeout(this._server.options.socketTimeout || SOCKET_TIMEOUT, () => this._onTimeout());\n        this._socket.pipe(this._parser);\n    }\n\n    /**\n     * Fired when the socket is closed\n     * @event\n     */\n    _onClose( /* hadError */ ) {\n        if (this._parser) {\n            this._parser.closed = true;\n            this._socket.unpipe(this._parser);\n            this._parser = false;\n        }\n\n        if (this._dataStream) {\n            this._dataStream.unpipe();\n            this._dataStream = null;\n        }\n\n        this._server.connections.delete(this);\n\n        if (this._closed) {\n            return;\n        }\n\n        this._closed = true;\n        this._closing = false;\n\n        this._server.logger.info({\n            tnx: 'close',\n            cid: this._id,\n            host: this.remoteAddress,\n            user: this.session.user && this.session.user.username\n        }, 'Connection closed to %s', this.clientHostname || this.remoteAddress);\n        setImmediate(() => this._server.onClose(this.session));\n    }\n\n    /**\n     * Fired when an error occurs with the socket\n     *\n     * @event\n     * @param {Error} err Error object\n     */\n    _onError(err) {\n        if ((err.code === 'ECONNRESET' || err.code === 'EPIPE') &&\n            (!this.session.envelope || !this.session.envelope.mailFrom)) {\n            // We got a connection error outside transaction. In most cases it means dirty\n            // connection ending by the other party, so we can just ignore it\n            this.close(); // mark connection as 'closing'\n            return;\n        }\n\n        this._server.logger.error({\n            err,\n            tnx: 'error',\n            user: this.session.user && this.session.user.username\n        }, '%s', err.message);\n        this.emit('error', err);\n    }\n\n    /**\n     * Fired when socket timeouts. Closes connection\n     *\n     * @event\n     */\n    _onTimeout() {\n        this.send(421, 'Timeout - closing connection');\n    }\n\n    /**\n     * Checks if a selected command is available and ivokes it\n     *\n     * @param {Buffer} command Single line of data from the client\n     * @param {Function} callback Callback to run once the command is processed\n     */\n    _onCommand(command, callback) {\n        let commandName = (command || '').toString().split(' ').shift().toUpperCase();\n        this._server.logger.debug({\n            tnx: 'command',\n            cid: this._id,\n            command: commandName,\n            user: this.session.user && this.session.user.username\n        }, 'C:', (command || '').toString());\n\n        let handler;\n        let params;\n\n        if (!this._ready) {\n            if (this._server.options.useProxy) {\n                params = (command || '').toString().split(' ');\n                commandName = params.shift().toUpperCase();\n                if (commandName !== 'PROXY') {\n                    this.send(500, 'Invalid PROXY header');\n                    return this.close();\n                }\n\n                if (params[1]) {\n                    this._server.logger.info({\n                        tnx: 'proxy',\n                        cid: this._id,\n                        proxy: params[1].trim().toLowerCase(),\n                        destination: this.remoteAddress,\n                        user: this.session.user && this.session.user.username\n                    }, 'PROXY from %s through %s', params[1].trim().toLowerCase(), this.remoteAddress);\n                    this.remoteAddress = params[1].trim().toLowerCase();\n                    if (params[3]) {\n                        this.remotePort = Number(params[3].trim()) || this.remotePort;\n                    }\n                    this.emitConnection();\n                }\n\n                return this.connectionReady(callback);\n            } else {\n                // block spammers that send payloads before server greeting\n                return this.send(421, this.name + ' You talk too soon');\n            }\n        }\n\n        // block malicious web pages that try to make SMTP calls from an AJAX request\n        if (/^(OPTIONS|GET|HEAD|POST|PUT|DELETE|TRACE|CONNECT) \\/.* HTTP\\/\\d\\.\\d$/i.test(command)) {\n            return this.send(421, 'HTTP requests not allowed');\n        }\n\n        callback = callback || (() => false);\n\n        if (this._upgrading) {\n            // ignore any commands before TLS upgrade is finished\n            return callback();\n        }\n\n        if (this._nextHandler) {\n            // If we already have a handler method queued up then use this\n            handler = this._nextHandler;\n            this._nextHandler = false;\n        } else {\n            // detect handler from the command name\n            switch (commandName) {\n                case 'HELO':\n                case 'EHLO':\n                case 'LHLO':\n                    this.openingCommand = commandName;\n                    break;\n            }\n            if (this._server.options.lmtp) {\n                switch (commandName) {\n                    case 'HELO':\n                    case 'EHLO':\n                        this.send(500, 'Error: ' + commandName + ' not allowed in LMTP server');\n                        return setImmediate(callback);\n                    case 'LHLO':\n                        commandName = 'EHLO';\n                        break;\n                }\n            }\n            if (this._isSupported(commandName)) {\n                handler = this['handler_' + commandName];\n            }\n        }\n\n        if (!handler) {\n            // if the user makes more\n            this._unrecognizedCommands++;\n            if (this._unrecognizedCommands >= 10) {\n                return this.send(421, 'Error: too many unrecognized commands');\n            }\n\n            this.send(500, 'Error: command not recognized');\n            return setImmediate(callback);\n        }\n\n        // block users that try to fiddle around without logging in\n        if (!this.session.user && this._isSupported('AUTH') && commandName !== 'AUTH') {\n            this._unauthenticatedCommands++;\n            if (this._unauthenticatedCommands >= 10) {\n                return this.send(421, 'Error: too many unauthenticated commands');\n            }\n        }\n\n        if (!this.hostNameAppearsAs && commandName && ['MAIL', 'RCPT', 'DATA', 'AUTH'].includes(commandName)) {\n            this.send(503, 'Error: send ' + (this._server.options.lmtp ? 'LHLO' : 'HELO/EHLO') + ' first');\n            return setImmediate(callback);\n        }\n\n        // Check if authentication is required\n        if (!this.session.user && this._isSupported('AUTH') && ['MAIL', 'RCPT', 'DATA'].includes(commandName) && !this._server.options.authOptional) {\n            this.send(530, 'Error: authentication Required');\n            return setImmediate(callback);\n        }\n\n        handler.call(this, command, callback);\n    }\n\n    /**\n     * Checks that a command is available and is not listed in the disabled commands array\n     *\n     * @param {String} command Command name\n     * @returns {Boolean} Returns true if the command can be used\n     */\n    _isSupported(command) {\n        command = (command || '').toString().trim().toUpperCase();\n        return !this._server.options.disabledCommands.includes(command) &&\n            typeof this['handler_' + command] === 'function';\n    }\n\n    /**\n     * Parses commands like MAIL FROM and RCPT TO. Returns an object with the address and optional arguments.\n     *\n     * @param {[type]} name Address type, eg 'mail from' or 'rcpt to'\n     * @param {[type]} command Data payload to parse\n     * @returns {Object|Boolean} Parsed address in the form of {address:, args: {}} or false if parsing failed\n     */\n    _parseAddressCommand(name, command) {\n        command = (command || '').toString();\n        name = (name || '').toString().trim().toUpperCase();\n\n        let parts = command.split(':');\n        command = parts.shift().trim().toUpperCase();\n        parts = parts.join(':').trim().split(/\\s+/);\n\n        let address = parts.shift();\n        let args = false;\n        let invalid = false;\n\n        if (name !== command) {\n            return false;\n        }\n\n        if (!/^<[^<>]*>$/.test(address)) {\n            invalid = true;\n        } else {\n            address = address.substr(1, address.length - 2);\n        }\n\n        parts.forEach(part => {\n            part = part.split('=');\n            let key = part.shift().toUpperCase();\n            let value = part.join('=') || true;\n\n            if (typeof value === 'string') {\n                // decode 'xtext'\n                value = value.replace(/\\+([0-9A-F]{2})/g, (match, hex) => unescape('%' + hex));\n            }\n\n            if (!args) {\n                args = {};\n            }\n\n            args[key] = value;\n        });\n\n        if (address) {\n            // enforce unycode\n            address = address.split('@');\n            if (address.length !== 2 || !address[0] || !address[1]) { // really bad e-mail address validation. was not able to use joi because of the missing unicode support\n                invalid = true;\n            } else {\n                address = [address[0] || '', '@', punycode.toUnicode(address[1] || '')].join('');\n            }\n        }\n\n        return invalid ? false : {\n            address,\n            args\n        };\n    }\n\n    /**\n     * Resets or sets up a new session. We reuse existing session object to keep\n     * application specific data.\n     */\n    _resetSession() {\n\n        let session = this.session;\n\n        // reset data that might be overwritten\n        session.remoteAddress = this.remoteAddress;\n        session.remotePort = this.remotePort;\n        session.clientHostname = this.clientHostname;\n        session.openingCommand = this.openingCommand;\n        session.hostNameAppearsAs = this.hostNameAppearsAs;\n        session.xClient = this._xClient;\n        session.xForward = this._xForward;\n        session.transmissionType = this._transmissionType();\n\n        session.tlsOptions = this.tlsOptions;\n\n        // reset transaction properties\n        session.envelope = {\n            mailFrom: false,\n            rcptTo: []\n        };\n\n        session.transaction = this._transactionCounter + 1;\n    }\n\n    /**\n     * Returns current transmission type\n     *\n     * @return {String} Transmission type\n     */\n    _transmissionType() {\n        let type = this._server.options.lmtp ? 'LMTP' : 'SMTP';\n\n        if (this.openingCommand === 'EHLO') {\n            type = 'E' + type;\n        }\n\n        if (this.secure) {\n            type += 'S';\n        }\n\n        if (this.session.user) {\n            type += 'A';\n        }\n\n        return type;\n    }\n\n    emitConnection() {\n        if (!this._canEmitConnection) {\n            return;\n        }\n        this._canEmitConnection = false;\n        this.emit('connect', {\n            remoteAddress: this.remoteAddress,\n            remotePort: this.remotePort,\n            hostNameAppearsAs: this.hostNameAppearsAs,\n            clientHostname: this.clientHostname\n        });\n    }\n\n    // COMMAND HANDLERS\n\n    /**\n     * Processes EHLO. Requires valid hostname as the single argument.\n     */\n    handler_EHLO(command, callback) {\n        let parts = command.toString().trim().split(/\\s+/);\n        let hostname = parts[1] || '';\n\n        if (parts.length !== 2) {\n            this.send(501, 'Error: syntax: ' + (this._server.options.lmtp ? 'LHLO' : 'EHLO') + ' hostname');\n            return callback();\n        }\n\n        this.hostNameAppearsAs = hostname.toLowerCase();\n\n        let features = ['PIPELINING', '8BITMIME', 'SMTPUTF8'].filter(feature => !this._server.options['hide' + feature]);\n\n        if (this._server.options.authMethods.length && this._isSupported('AUTH')) {\n            features.push(['AUTH'].concat(this._server.options.authMethods).join(' '));\n        }\n\n        if (!this.secure && this._isSupported('STARTTLS') && !this._server.options.hideSTARTTLS) {\n            features.push('STARTTLS');\n        }\n\n        if (this._server.options.size) {\n            features.push('SIZE' + (this._server.options.hideSize ? '' : ' ' + this._server.options.size));\n        }\n\n        // XCLIENT ADDR removes any special privileges for the client\n        if (!this._xClient.has('ADDR') && this._server.options.useXClient && this._isSupported('XCLIENT')) {\n            features.push('XCLIENT NAME ADDR PORT PROTO HELO LOGIN');\n        }\n\n        // If client has already issued XCLIENT ADDR then it does not have privileges for XFORWARD anymore\n        if (!this._xClient.has('ADDR') && this._server.options.useXForward && this._isSupported('XFORWARD')) {\n            features.push('XFORWARD NAME ADDR PORT PROTO HELO IDENT SOURCE');\n        }\n\n        this._resetSession(); // EHLO is effectively the same as RSET\n        this.send(250, [this.name + ' Nice to meet you, ' + this.clientHostname].concat(features || []));\n\n        callback();\n    }\n\n    /**\n     * Processes HELO. Requires valid hostname as the single argument.\n     */\n    handler_HELO(command, callback) {\n        let parts = command.toString().trim().split(/\\s+/);\n        let hostname = parts[1] || '';\n\n        if (parts.length !== 2) {\n            this.send(501, 'Error: Syntax: HELO hostname');\n            return callback();\n        }\n\n        this.hostNameAppearsAs = hostname.toLowerCase();\n\n        this._resetSession(); // HELO is effectively the same as RSET\n        this.send(250, this.name + ' Nice to meet you, ' + this.clientHostname);\n\n        callback();\n    }\n\n    /**\n     * Processes QUIT. Closes the connection\n     */\n    handler_QUIT(command, callback) {\n        this.send(221, 'Bye');\n        this.close();\n        callback();\n    }\n\n    /**\n     * Processes NOOP. Does nothing but keeps the connection alive\n     */\n    handler_NOOP(command, callback) {\n        this.send(250, 'OK');\n        callback();\n    }\n\n    /**\n     * Processes RSET. Resets user and session info\n     */\n    handler_RSET(command, callback) {\n        this._resetSession();\n\n        this.send(250, 'Flushed');\n        callback();\n    }\n\n    /**\n     * Processes HELP. Responds with url to RFC\n     */\n    handler_HELP(command, callback) {\n        this.send(214, 'See https://tools.ietf.org/html/rfc5321 for details');\n        callback();\n    }\n\n    /**\n     * Processes VRFY. Does not verify anything\n     */\n    handler_VRFY(command, callback) {\n        this.send(252, 'Try to send something. No promises though');\n        callback();\n    }\n\n    /**\n     * Overrides connection info\n     * http://www.postfix.org/XCLIENT_README.html\n     *\n     * TODO: add unit tests\n     */\n    handler_XCLIENT(command, callback) {\n        // check if user is authorized to perform this command\n        if (this._xClient.has('ADDR') || !this._server.options.useXClient) {\n            this.send(550, 'Error: Not allowed');\n            return callback();\n        }\n\n        // not allowed to change properties if already processing mail\n        if (this.session.envelope.mailFrom) {\n            this.send(503, 'Error: Mail transaction in progress');\n            return callback();\n        }\n\n        let allowedKeys = ['NAME', 'ADDR', 'PORT', 'PROTO', 'HELO', 'LOGIN'];\n        let parts = command.toString().trim().split(/\\s+/);\n        let key, value;\n        let data = new Map();\n        parts.shift(); // remove XCLIENT prefix\n\n        if (!parts.length) {\n            this.send(501, 'Error: Bad command parameter syntax');\n            return callback();\n        }\n\n        // parse and validate arguments\n        for (let i = 0, len = parts.length; i < len; i++) {\n            value = parts[i].split('=');\n            key = value.shift();\n            if (value.length !== 1 || !allowedKeys.includes(key.toUpperCase())) {\n                this.send(501, 'Error: Bad command parameter syntax');\n                return callback();\n            }\n            key = key.toUpperCase();\n\n            // value is xtext\n            value = (value[0] || '').replace(/\\+([0-9A-F]{2})/g, (match, hex) => unescape('%' + hex));\n\n            if (['[UNAVAILABLE]', '[TEMPUNAVAIL]'].includes(value.toUpperCase())) {\n                value = false;\n            }\n\n            if (data.has(key)) {\n                // ignore duplicate keys\n                continue;\n            }\n\n            data.set(key, value);\n\n            switch (key) {\n                case 'LOGIN':\n                    if (!value) {\n                        if (this.session.user) {\n                            this._server.logger.info({\n                                tnx: 'deauth',\n                                cid: this._id,\n                                user: this.session.user && this.session.user.username\n                            }, 'User deauthenticated using %s', 'XCLIENT');\n                            this.session.user = false;\n                        }\n                    } else {\n                        this._server.logger.info({\n                            tnx: 'auth',\n                            cid: this._id,\n                            user: value\n                        }, '%s authenticated using %s', value, 'XCLIENT');\n\n                        this.session.user = {\n                            username: value\n                        };\n                    }\n                    break;\n                case 'ADDR':\n                    if (value) {\n                        value = value.replace(/^IPV6:/i, ''); // IPv6 addresses are prefixed with \"IPv6:\"\n\n                        if (!net.isIP(value)) {\n                            this.send(501, 'Error: Bad command parameter syntax. Invalid address');\n                            return callback();\n                        }\n\n                        if (net.isIPv6(value)) {\n                            value = ipv6normalize(value);\n                        }\n\n                        this._server.logger.info({\n                            tnx: 'xclient',\n                            cid: this._id,\n                            xclientKey: 'ADDR',\n                            xclient: value,\n                            user: this.session.user && this.session.user.username\n                        }, 'XCLIENT from %s through %s', value, this.remoteAddress);\n\n                        // store original value for reference as ADDR:DEFAULT\n                        if (!this._xClient.has('ADDR:DEFAULT')) {\n                            this._xClient.set('ADDR:DEFAULT', this.remoteAddress);\n                        }\n\n                        this.remoteAddress = value;\n                        this.hostNameAppearsAs = false; // reset client provided hostname, require HELO/EHLO\n                    }\n                    break;\n                case 'NAME':\n                    value = value || '';\n                    this._server.logger.info({\n                        tnx: 'xclient',\n                        cid: this._id,\n                        xclientKey: 'NAME',\n                        xclient: value,\n                        user: this.session.user && this.session.user.username\n                    }, 'XCLIENT hostname resolved as \"%s\"', value);\n\n                    // store original value for reference as NAME:DEFAULT\n                    if (!this._xClient.has('NAME:DEFAULT')) {\n                        this._xClient.set('NAME:DEFAULT', this.clientHostname || '');\n                    }\n\n                    this.clientHostname = value.toLowerCase();\n                    break;\n                case 'PORT':\n                    value = Number(value) || '';\n                    this._server.logger.info({\n                        tnx: 'xclient',\n                        cid: this._id,\n                        xclientKey: 'PORT',\n                        xclient: value,\n                        user: this.session.user && this.session.user.username\n                    }, 'XCLIENT remote port resolved as \"%s\"', value);\n\n                    // store original value for reference as NAME:DEFAULT\n                    if (!this._xClient.has('PORT:DEFAULT')) {\n                        this._xClient.set('PORT:DEFAULT', this.remotePort || '');\n                    }\n\n                    this.remotePort = value;\n                    break;\n                default:\n                    // other values are not relevant\n            }\n            this._xClient.set(key, value);\n        }\n\n        // Use [ADDR] if NAME was empty\n        if (this.remoteAddress && !this.clientHostname) {\n            this.clientHostname = '[' + this.remoteAddress + ']';\n        }\n\n        if (data.has('ADDR')) {\n            this.emitConnection();\n        }\n\n        // success\n        this.send(220, this.name + ' ' + (this._server.options.lmtp ? 'LMTP' : 'ESMTP') + (this._server.options.banner ? ' ' + this._server.options.banner : ''));\n        callback();\n    }\n\n    /**\n     * Processes XFORWARD data\n     * http://www.postfix.org/XFORWARD_README.html\n     *\n     * TODO: add unit tests\n     */\n    handler_XFORWARD(command, callback) {\n        // check if user is authorized to perform this command\n        if (!this._server.options.useXForward) {\n            this.send(550, 'Error: Not allowed');\n            return callback();\n        }\n\n        // not allowed to change properties if already processing mail\n        if (this.session.envelope.mailFrom) {\n            this.send(503, 'Error: Mail transaction in progress');\n            return callback();\n        }\n\n        let allowedKeys = ['NAME', 'ADDR', 'PORT', 'PROTO', 'HELO', 'IDENT', 'SOURCE'];\n        let parts = command.toString().trim().split(/\\s+/);\n        let key, value;\n        let data = new Map();\n        let hasAddr = false;\n        parts.shift(); // remove XFORWARD prefix\n\n        if (!parts.length) {\n            this.send(501, 'Error: Bad command parameter syntax');\n            return callback();\n        }\n\n        // parse and validate arguments\n        for (let i = 0, len = parts.length; i < len; i++) {\n            value = parts[i].split('=');\n            key = value.shift();\n            if (value.length !== 1 || !allowedKeys.includes(key.toUpperCase())) {\n                this.send(501, 'Error: Bad command parameter syntax');\n                return callback();\n            }\n            key = key.toUpperCase();\n            if (data.has(key)) {\n                // ignore duplicate keys\n                continue;\n            }\n\n            // value is xtext\n            value = (value[0] || '').replace(/\\+([0-9A-F]{2})/g, (match, hex) => unescape('%' + hex));\n\n            if (value.toUpperCase() === '[UNAVAILABLE]') {\n                value = false;\n            }\n\n            data.set(key, value);\n\n            switch (key) {\n                case 'ADDR':\n                    if (value) {\n                        value = value.replace(/^IPV6:/i, ''); // IPv6 addresses are prefixed with \"IPv6:\"\n\n                        if (!net.isIP(value)) {\n                            this.send(501, 'Error: Bad command parameter syntax. Invalid address');\n                            return callback();\n                        }\n\n                        if (net.isIPv6(value)) {\n                            value = ipv6normalize(value);\n                        }\n\n                        this._server.logger.info({\n                            tnx: 'xforward',\n                            cid: this._id,\n                            xforwardKey: 'ADDR',\n                            xforward: value,\n                            user: this.session.user && this.session.user.username\n                        }, 'XFORWARD from %s through %s', value, this.remoteAddress);\n\n                        // store original value for reference as ADDR:DEFAULT\n                        if (!this._xClient.has('ADDR:DEFAULT')) {\n                            this._xClient.set('ADDR:DEFAULT', this.remoteAddress);\n                        }\n\n                        hasAddr = true;\n                        this.remoteAddress = value;\n                    }\n                    break;\n                case 'NAME':\n                    value = value || '';\n                    this._server.logger.info({\n                        tnx: 'xforward',\n                        cid: this._id,\n                        xforwardKey: 'NAME',\n                        xforward: value,\n                        user: this.session.user && this.session.user.username\n                    }, 'XFORWARD hostname resolved as \"%s\"', value);\n                    this.clientHostname = value.toLowerCase();\n                    break;\n                case 'PORT':\n                    value = Number(value) || 0;\n                    this._server.logger.info({\n                        tnx: 'xforward',\n                        cid: this._id,\n                        xforwardKey: 'PORT',\n                        xforward: value,\n                        user: this.session.user && this.session.user.username\n                    }, 'XFORWARD port resolved as \"%s\"', value);\n                    this.remotePort = value;\n                    break;\n                case 'HELO':\n                    value = Number(value) || 0;\n                    this._server.logger.info({\n                        tnx: 'xforward',\n                        cid: this._id,\n                        xforwardKey: 'HELO',\n                        xforward: value,\n                        user: this.session.user && this.session.user.username\n                    }, 'XFORWARD HELO name resolved as \"%s\"', value);\n                    this.hostNameAppearsAs = value;\n                    break;\n                default:\n                    // other values are not relevant\n            }\n            this._xForward.set(key, value);\n        }\n\n        if (hasAddr) {\n            this._canEmitConnection = true;\n            this.emitConnection();\n        }\n\n        // success\n        this.send(250, 'OK');\n        callback();\n    }\n\n    /**\n     * Upgrades connection to TLS if possible\n     */\n    handler_STARTTLS(command, callback) {\n\n        if (this.secure) {\n            this.send(503, 'Error: TLS already active');\n            return callback();\n        }\n\n        this.send(220, 'Ready to start TLS');\n        this._socket.unpipe(this._parser);\n        this._upgrading = true;\n        setImmediate(callback); // resume input stream\n\n        let secureContext = this._server.secureContext.get('default');\n        let socketOptions = {\n            secureContext,\n            isServer: true,\n            server: this._server.server,\n\n            SNICallback: (servername, cb) => {\n                cb(null, this._server.secureContext.get(servername.toLowerCase().trim()) || this._server.secureContext.get('default'));\n            }\n        };\n\n        // Apply additional socket options if these are set in the server options\n        ['requestCert', 'rejectUnauthorized', 'NPNProtocols', 'SNICallback', 'session', 'requestOCSP'].forEach(key => {\n            if (key in this._server.options) {\n                socketOptions[key] = this._server.options[key];\n            }\n        });\n\n        // remove all listeners from the original socket besides the error handler\n        this._socket.removeAllListeners();\n        this._socket.on('error', err => this._onError(err));\n\n        // upgrade connection\n        let secureSocket = new tls.TLSSocket(this._socket, socketOptions);\n\n        secureSocket.on('close', () => this._onClose());\n        secureSocket.on('error', err => this._onError(err));\n        secureSocket.on('clientError', err => this._onError(err));\n        secureSocket.setTimeout(this._server.options.socketTimeout || SOCKET_TIMEOUT, () => this._onTimeout());\n\n        secureSocket.on('secure', () => {\n            this.session.secure = this.secure = true;\n            this._socket = secureSocket;\n            this._upgrading = false;\n\n            this.session.tlsOptions = this.tlsOptions = this._socket.getCipher();\n            let cipher = this.session.tlsOptions && this.session.tlsOptions.name;\n            this._server.logger.info({\n                tnx: 'starttls',\n                cid: this._id,\n                user: this.session.user && this.session.user.username,\n                cipher\n            }, 'Connection upgraded to TLS using ', cipher || 'N/A');\n            this._socket.pipe(this._parser);\n        });\n    }\n\n    /**\n     * Check if selected authentication is available and delegate auth data to SASL\n     */\n    handler_AUTH(command, callback) {\n        let args = command.toString().trim().split(/\\s+/);\n        let method;\n        let handler;\n\n        args.shift(); // remove AUTH\n        method = (args.shift() || '').toString().toUpperCase(); // get METHOD and keep additional arguments in the array\n        handler = sasl['SASL_' + method];\n        handler = handler ? handler.bind(this) : handler;\n\n        if (!this.secure && this._isSupported('STARTTLS') && !this._server.options.hideSTARTTLS && !this._server.options.allowInsecureAuth) {\n            this.send(538, 'Error: Must issue a STARTTLS command first');\n            return callback();\n        }\n\n        if (this.session.user) {\n            this.send(503, 'Error: No identity changes permitted');\n            return callback();\n        }\n\n        if (!this._server.options.authMethods.includes(method) || typeof handler !== 'function') {\n            this.send(504, 'Error: Unrecognized authentication type');\n            return callback();\n        }\n\n        handler(args, callback);\n    }\n\n    /**\n     * Processes MAIL FROM command, parses address and extra arguments\n     */\n    handler_MAIL(command, callback) {\n        let parsed = this._parseAddressCommand('mail from', command);\n\n        // in case we still haven't informed about the new connection emit it\n        this.emitConnection();\n\n        // sender address can be empty, so we only check if parsing failed or not\n        if (!parsed) {\n            this.send(501, 'Error: Bad sender address syntax');\n            return callback();\n        }\n\n        if (this.session.envelope.mailFrom) {\n            this.send(503, 'Error: nested MAIL command');\n            return callback();\n        }\n\n        if (!this._server.options.hideSize && this._server.options.size && parsed.args.SIZE && Number(parsed.args.SIZE) > this._server.options.size) {\n            this.send(552, 'Error: message exceeds fixed maximum message size ' + this._server.options.size);\n            return callback();\n        }\n\n        this._server.onMailFrom(parsed, this.session, err => {\n            if (err) {\n                this.send(err.responseCode || 550, err.message);\n                return callback();\n            }\n\n            this.session.envelope.mailFrom = parsed;\n\n            this.send(250, 'Accepted');\n            callback();\n        });\n    }\n\n    /**\n     * Processes RCPT TO command, parses address and extra arguments\n     */\n    handler_RCPT(command, callback) {\n        let parsed = this._parseAddressCommand('rcpt to', command);\n\n        // recipient address can not be empty\n        if (!parsed || !parsed.address) {\n            this.send(501, 'Error: Bad recipient address syntax');\n            return callback();\n        }\n\n        if (!this.session.envelope.mailFrom) {\n            this.send(503, 'Error: need MAIL command');\n            return callback();\n        }\n\n        this._server.onRcptTo(parsed, this.session, err => {\n            if (err) {\n                this.send(err.responseCode || 550, err.message);\n                return callback();\n            }\n\n            // check if the address is already used, if so then overwrite\n            for (let i = 0, len = this.session.envelope.rcptTo.length; i < len; i++) {\n                if (this.session.envelope.rcptTo[i].address.toLowerCase() === parsed.address.toLowerCase()) {\n                    this.session.envelope.rcptTo[i] = parsed;\n                    parsed = false;\n                    break;\n                }\n            }\n\n            if (parsed) {\n                this.session.envelope.rcptTo.push(parsed);\n            }\n\n            this.send(250, 'Accepted');\n            callback();\n        });\n    }\n\n    /**\n     * Processes DATA by forwarding incoming stream to the onData handler\n     */\n    handler_DATA(command, callback) {\n        if (!this.session.envelope.rcptTo.length) {\n            this.send(503, 'Error: need RCPT command');\n            return callback();\n        }\n\n        if (!this._parser) {\n            return callback();\n        }\n\n        this._dataStream = this._parser.startDataMode(this._server.options.size);\n\n        let close = (err, message) => {\n            let i, len;\n\n            this._server.logger.debug({\n                tnx: 'data',\n                cid: this._id,\n                bytes: this._parser.dataBytes,\n                user: this.session.user && this.session.user.username\n            }, 'C: <%s bytes of DATA>', this._parser.dataBytes);\n\n            if ((typeof this._dataStream === 'object') && (this._dataStream) && (this._dataStream.readable)) {\n                this._dataStream.removeAllListeners();\n            }\n\n            if (err) {\n                if (this._server.options.lmtp) {\n                    // separate error response for every recipient when using LMTP\n                    for (i = 0, len = this.session.envelope.rcptTo.length; i < len; i++) {\n                        this.send(err.responseCode || 450, err.message);\n                    }\n                } else {\n                    // single error response when using SMTP\n                    this.send(err.responseCode || 450, err.message);\n                }\n            } else if (Array.isArray(message)) {\n                // separate responses for every recipient when using LMTP\n                message.forEach(response => {\n                    if (/Error\\]$/i.test(Object.prototype.toString.call(response))) {\n                        this.send(response.responseCode || 450, response.message);\n                    } else {\n                        this.send(250, typeof response === 'string' ? response : 'OK: message accepted');\n                    }\n                });\n            } else if (this._server.options.lmtp) {\n                // separate success response for every recipient when using LMTP\n                for (i = 0, len = this.session.envelope.rcptTo.length; i < len; i++) {\n                    this.send(250, typeof message === 'string' ? message : 'OK: message accepted');\n                }\n            } else {\n                // single success response when using SMTP\n                this.send(250, typeof message === 'string' ? message : 'OK: message queued');\n            }\n\n            this._transactionCounter++;\n\n            this._unrecognizedCommands = 0; // reset unrecognized commands counter\n            this._resetSession(); // reset session state\n\n            if ((typeof this._parser === 'object') && (this._parser)) {\n                this._parser.continue();\n            }\n        };\n\n        this._server.onData(this._dataStream, this.session, (err, message) => {\n            // ensure _dataStream is an object and not set to null by premature closing\n            // do not continue until the stream has actually ended\n            if ((typeof this._dataStream === 'object') && (this._dataStream) && (this._dataStream.readable)) {\n                this._dataStream.on('end', () => close(err, message));\n                return;\n            }\n            close(err, message);\n        });\n\n        this.send(354, 'End data with <CR><LF>.<CR><LF>');\n        callback();\n    }\n\n    // Dummy handlers for some old sendmail specific commands\n\n    /**\n     * Processes sendmail WIZ command, upgrades to \"wizard mode\"\n     */\n    handler_WIZ(command, callback) {\n        let args = command.toString().trim().split(/\\s+/);\n        let password;\n\n        args.shift(); // remove WIZ\n        password = (args.shift() || '').toString();\n\n        // require password argument\n        if (!password) {\n            this.send(500, 'You are no wizard!');\n            return callback();\n        }\n\n        // all passwords pass validation, so everyone is a wizard!\n        this.session.isWizard = true;\n        this.send(200, 'Please pass, oh mighty wizard');\n        callback();\n    }\n\n    /**\n     * Processes sendmail SHELL command, should return interactive shell but this is a dummy function\n     * so no actual shell is provided to the client\n     */\n    handler_SHELL(command, callback) {\n        this._server.logger.info({\n            tnx: 'shell',\n            cid: this._id,\n            user: this.session.user && this.session.user.username\n        }, 'Client tried to invoke SHELL');\n\n        if (!this.session.isWizard) {\n            this.send(500, 'Mere mortals musn\\'t mutter that mantra');\n            return callback();\n        }\n\n        this.send(500, 'Error: Invoking shell is not allowed. This incident will be reported.');\n        callback();\n    }\n\n    /**\n     * Processes sendmail KILL command\n     */\n    handler_KILL(command, callback) {\n        this._server.logger.info({\n            tnx: 'kill',\n            cid: this._id,\n            user: this.session.user && this.session.user.username\n        }, 'Client tried to invoke KILL');\n\n        this.send(500, 'Can\\'t kill Mom');\n        callback();\n    }\n\n}\n// Expose to the world\nmodule.exports.SMTPConnection = SMTPConnection;\n","/home/travis/build/npmtest/node-npmtest-smtp-server/node_modules/smtp-server/lib/smtp-stream.js":"'use strict';\n\nconst stream = require('stream');\nconst Writable = stream.Writable;\nconst PassThrough = stream.PassThrough;\n\n/**\n * Incoming SMTP stream parser. Detects and emits commands. If switched to\n * data mode, emits unescaped data events until final .\n *\n * @constructor\n * @param {Object} [options] Optional Stream options object\n */\nclass SMTPStream extends Writable {\n    constructor(options) {\n        // init Writable\n        super(options);\n\n        // Indicates if the stream is currently in data mode\n        this._dataMode = false;\n        // Output stream for the current data mode\n        this._dataStream = null;\n        // How many bytes are allowed for a data stream\n        this._maxBytes = Infinity;\n        // How many bytes have been emitted to data stream\n        this.dataBytes = 0;\n        // Callback to run once data mode is finished\n        this._continueCallback = false;\n        // unprocessed chars from the last parsing iteration (used in command mode)\n        this._remainder = '';\n        // unprocessed bytes from the last parsing iteration (used in data mode)\n        this._lastBytes = false;\n\n        this.closed = false;\n        // once the input stream ends, flush all output without expecting the newline\n        this.on('finish', () => this._flushData());\n    }\n\n    /**\n     * Placeholder command handler. Override this with your own.\n     */\n    oncommand( /* command, callback */ ) {\n        throw new Error('Command handler is not set');\n    }\n\n    /**\n     * Switch to data mode and return output stream. The dots in the stream are unescaped.\n     *\n     * @returns {Stream} Data stream\n     */\n    startDataMode(maxBytes) {\n        this._dataMode = true;\n        this._maxBytes = maxBytes && Number(maxBytes) || Infinity;\n        this.dataBytes = 0;\n        this._dataStream = new PassThrough();\n\n        return this._dataStream;\n    }\n\n    /**\n     * Call this once data mode is over and you have finished processing the data stream\n     */\n    continue () {\n        if (typeof this._continueCallback === 'function') {\n            this._continueCallback();\n            this._continueCallback = false;\n        } else {\n            // indicate that the 'continue' was already called once the stream actually ends\n            this._continueCallback = true;\n        }\n    }\n\n    // PRIVATE METHODS\n\n    /**\n     * Writable._write method.\n     */\n    _write(chunk, encoding, next) {\n        if (!chunk || !chunk.length) {\n            return next();\n        }\n\n        let data;\n        let pos = 0;\n        let newlineRegex;\n\n        let called = false;\n        let done = (...args) => {\n            if (called) {\n                return;\n            }\n            called = true;\n            next(...args);\n        };\n\n        if (this.closed) {\n            return done();\n        }\n\n        if (!this._dataMode) {\n\n            newlineRegex = /\\r?\\n/g;\n            data = this._remainder + chunk.toString('binary');\n\n            let readLine = () => {\n                let match;\n                let line;\n                let buf;\n\n                // check if the mode is not changed\n                if (this._dataMode) {\n                    buf = new Buffer(data.substr(pos), 'binary');\n                    this._remainder = '';\n                    return this._write(buf, 'buffer', done);\n                }\n\n                // search for the next newline\n                // exec keeps count of the last match with lastIndex\n                // so it knows from where to start with the next iteration\n                if ((match = newlineRegex.exec(data))) {\n                    line = data.substr(pos, match.index - pos);\n                    pos += line.length + match[0].length;\n                } else {\n                    this._remainder = pos < data.length ? data.substr(pos) : '';\n                    return done();\n                }\n\n                this.oncommand(new Buffer(line, 'binary'), readLine);\n            };\n\n            // start reading lines\n            readLine();\n\n        } else {\n            this._feedDataStream(chunk, done);\n        }\n    }\n\n    /**\n     * Processes a chunk in data mode. Escape dots are removed and final dot ends the data mode.\n     */\n    _feedDataStream(chunk, done) {\n        let i;\n        let endseq = new Buffer('\\r\\n.\\r\\n');\n        let len;\n        let handled;\n        let buf;\n\n        if (this._lastBytes && this._lastBytes.length) {\n            chunk = Buffer.concat([this._lastBytes, chunk], this._lastBytes.length + chunk.length);\n            this._lastBytes = false;\n        }\n\n        len = chunk.length;\n\n        // check if the data does not start with the end terminator\n        if (!this.dataBytes && len >= 3 && Buffer.compare(chunk.slice(0, 3), new Buffer('.\\r\\n')) === 0) {\n            this._endDataMode(false, chunk.slice(3), done);\n            return;\n        }\n\n        // check if the first symbol is a escape dot\n        if (!this.dataBytes && len >= 2 && chunk[0] === 0x2E && chunk[1] === 0x2E) {\n            chunk = chunk.slice(1);\n            len--;\n        }\n\n        // seek for the stream ending\n        for (i = 2; i < len - 2; i++) {\n\n            // if the dot is the first char in a line\n            if (chunk[i] === 0x2E && chunk[i - 1] === 0x0A) {\n\n                // if the dot matches end terminator\n                if (Buffer.compare(chunk.slice(i - 2, i + 3), endseq) === 0) {\n\n                    if (i > 2) {\n                        buf = chunk.slice(0, i);\n                        this.dataBytes += buf.length;\n                        this._endDataMode(buf, chunk.slice(i + 3), done);\n                    } else {\n                        this._endDataMode(false, chunk.slice(i + 3), done);\n                    }\n\n                    return;\n                }\n\n                // check if the dot is an escape char and remove it\n                if (chunk[i + 1] === 0x2E) {\n                    buf = chunk.slice(0, i);\n\n                    this._lastBytes = false; // clear remainder bytes\n                    this.dataBytes += buf.length; // increment byte counter\n\n                    // emit what we already have and continue without the dot\n                    if (this._dataStream.writable) {\n                        this._dataStream.write(buf);\n                    }\n\n                    return setImmediate(() => this._feedDataStream(chunk.slice(i + 1), done));\n                }\n            }\n        }\n\n        // keep the last bytes\n        if (chunk.length < 4) {\n            this._lastBytes = chunk;\n        } else {\n            this._lastBytes = chunk.slice(chunk.length - 4);\n        }\n\n        // if current chunk is longer than the remainder bytes we keep for later emit the available bytes\n        if (this._lastBytes.length < chunk.length) {\n\n            buf = chunk.slice(0, chunk.length - this._lastBytes.length);\n            this.dataBytes += buf.length;\n\n            // write to stream but stop if need to wait for drain\n            if (this._dataStream.writable) {\n                handled = this._dataStream.write(buf);\n                if (!handled) {\n                    this._dataStream.once('drain', done);\n                } else {\n                    return done();\n                }\n            } else {\n                return done();\n            }\n\n        } else {\n            // nothing to emit, continue with the input stream\n            return done();\n        }\n    }\n\n    /**\n     * Flushes remaining bytes\n     */\n    _flushData() {\n        let line;\n        if (this._remainder && !this.closed) {\n            line = this._remainder;\n            this._remainder = '';\n            this.oncommand(new Buffer(line, 'binary'));\n        }\n    }\n\n    /**\n     * Ends data mode and returns to command mode. Stream is not resumed before #continue is called\n     */\n    _endDataMode(chunk, remainder, callback) {\n        if (this._continueCallback === true) {\n            this._continueCallback = false;\n            // wait until the stream is actually over and then continue\n            this._dataStream.once('end', callback);\n        } else {\n            this._continueCallback = () => this._write(remainder, 'buffer', callback);\n        }\n\n        this._dataStream.byteLength = this.dataBytes;\n        this._dataStream.sizeExceeded = this.dataBytes > this._maxBytes;\n\n        if (chunk && chunk.length && this._dataStream.writable) {\n            this._dataStream.end(chunk);\n        } else {\n            this._dataStream.end();\n        }\n\n        this._dataMode = false;\n        this._remainder = '';\n        this._dataStream = null;\n    }\n\n}\n\n// Expose to the world\nmodule.exports.SMTPStream = SMTPStream;\n","/home/travis/build/npmtest/node-npmtest-smtp-server/node_modules/smtp-server/lib/sasl.js":"'use strict';\n\nconst util = require('util');\nconst crypto = require('crypto');\n\nconst SASL = module.exports = {\n\n    SASL_PLAIN(args, callback) {\n        if (args.length > 1) {\n            this.send(501, 'Error: syntax: AUTH PLAIN token');\n            return callback();\n        }\n\n        if (!args.length) {\n            this._nextHandler = SASL.PLAIN_token.bind(this, true);\n            this.send(334);\n            return callback();\n        }\n\n        SASL.PLAIN_token.call(this, false, args[0], callback);\n    },\n\n    SASL_LOGIN(args, callback) {\n        if (args.length > 1) {\n            this.send(501, 'Error: syntax: AUTH LOGIN');\n            return callback();\n        }\n\n        if (!args.length) {\n            this._nextHandler = SASL.LOGIN_username.bind(this, true);\n            this.send(334, 'VXNlcm5hbWU6');\n            return callback();\n        }\n\n        SASL.LOGIN_username.call(this, false, args[0], callback);\n    },\n\n    SASL_XOAUTH2(args, callback) {\n        if (args.length > 1) {\n            this.send(501, 'Error: syntax: AUTH XOAUTH2 token');\n            return callback();\n        }\n\n        if (!args.length) {\n            this._nextHandler = SASL.XOAUTH2_token.bind(this, true);\n            this.send(334);\n            return callback();\n        }\n\n        SASL.XOAUTH2_token.call(this, false, args[0], callback);\n    },\n\n    'SASL_CRAM-MD5' (args, callback) {\n        if (args.length) {\n            this.send(501, 'Error: syntax: AUTH CRAM-MD5');\n            return callback();\n        }\n\n        let challenge = util.format('<%s%s@%s>',\n            String(Math.random()).replace(/^[0\\.]+/, '').substr(0, 8), // random numbers\n            Math.floor(Date.now() / 1000), // timestamp\n            this.name // hostname\n        );\n\n        this._nextHandler = SASL['CRAM-MD5_token'].bind(this, true, challenge);\n        this.send(334, new Buffer(challenge).toString('base64'));\n        return callback();\n    },\n\n    PLAIN_token(canAbort, token, callback) {\n        token = (token || '').toString().trim();\n\n        if (canAbort && token === '*') {\n            this.send(501, 'Authentication aborted');\n            return callback();\n        }\n\n        let data = new Buffer(token, 'base64').toString().split('\\x00');\n\n        if (data.length !== 3) {\n            this.send(500, 'Error: invalid userdata');\n            return callback();\n        }\n\n        let username = data[1] || data[0] || '';\n        let password = data[2] || '';\n\n        this._server.onAuth({\n            method: 'PLAIN',\n            username,\n            password\n        }, this.session, (err, response) => {\n\n            if (err) {\n                this._server.logger.info({\n                    err,\n                    tnx: 'autherror',\n                    cid: this._id,\n                    method: 'PLAIN',\n                    user: username\n                }, 'Authentication error for %s using %s. %s', username, 'PLAIN', err.message);\n                this.send(err.responseCode || 535, err.message);\n                return callback();\n            }\n\n            if (!response.user) {\n                this._server.logger.info({\n                    tnx: 'authfail',\n                    cid: this._id,\n                    method: 'PLAIN',\n                    user: username\n                }, 'Authentication failed for %s using %s', username, 'PLAIN');\n                this.send(response.responseCode || 535, response.message || 'Error: Authentication credentials invalid');\n                return callback();\n            }\n\n            this._server.logger.info({\n                tnx: 'auth',\n                cid: this._id,\n                method: 'PLAIN',\n                user: username\n            }, '%s authenticated using %s', username, 'PLAIN');\n            this.session.user = response.user;\n            this.session.transmissionType = this._transmissionType();\n\n            this.send(235, 'Authentication successful');\n            callback();\n\n        });\n    },\n\n    LOGIN_username(canAbort, username, callback) {\n        username = (username || '').toString().trim();\n\n        if (canAbort && username === '*') {\n            this.send(501, 'Authentication aborted');\n            return callback();\n        }\n\n        username = new Buffer(username, 'base64').toString();\n\n        if (!username) {\n            this.send(500, 'Error: missing username');\n            return callback();\n        }\n\n        this._nextHandler = SASL.LOGIN_password.bind(this, username);\n        this.send(334, 'UGFzc3dvcmQ6');\n        return callback();\n    },\n\n    LOGIN_password(username, password, callback) {\n        password = (password || '').toString().trim();\n\n        if (password === '*') {\n            this.send(501, 'Authentication aborted');\n            return callback();\n        }\n\n        password = new Buffer(password, 'base64').toString();\n\n        this._server.onAuth({\n            method: 'LOGIN',\n            username,\n            password\n        }, this.session, (err, response) => {\n\n            if (err) {\n                this._server.logger.info({\n                    err,\n                    tnx: 'autherror',\n                    cid: this._id,\n                    method: 'LOGIN',\n                    user: username\n                }, 'Authentication error for %s using %s. %s', username, 'LOGIN', err.message);\n                this.send(err.responseCode || 535, err.message);\n                return callback();\n            }\n\n            if (!response.user) {\n                this._server.logger.info({\n                    tnx: 'authfail',\n                    cid: this._id,\n                    method: 'LOGIN',\n                    user: username\n                }, 'Authentication failed for %s using %s', username, 'LOGIN');\n                this.send(response.responseCode || 535, response.message || 'Error: Authentication credentials invalid');\n                return callback();\n            }\n\n            this._server.logger.info({\n                tnx: 'auth',\n                cid: this._id,\n                method: 'PLAIN',\n                user: username\n            }, '%s authenticated using %s', username, 'LOGIN');\n            this.session.user = response.user;\n            this.session.transmissionType = this._transmissionType();\n\n            this.send(235, 'Authentication successful');\n            callback();\n\n        });\n    },\n\n    XOAUTH2_token(canAbort, token, callback) {\n        token = (token || '').toString().trim();\n\n        if (canAbort && token === '*') {\n            this.send(501, 'Authentication aborted');\n            return callback();\n        }\n\n        let username;\n        let accessToken;\n\n        // Find username and access token from the input\n        new Buffer(token, 'base64').toString().split('\\x01').forEach(part => {\n            part = part.split('=');\n            let key = part.shift().toLowerCase();\n            let value = part.join('=').trim();\n\n            if (key === 'user') {\n                username = value;\n            } else if (key === 'auth') {\n                value = value.split(/\\s+/);\n                if (value.shift().toLowerCase() === 'bearer') {\n                    accessToken = value.join(' ');\n                }\n            }\n        });\n\n        if (!username || !accessToken) {\n            this.send(500, 'Error: invalid userdata');\n            return callback();\n        }\n\n        this._server.onAuth({\n            method: 'XOAUTH2',\n            username,\n            accessToken\n        }, this.session, (err, response) => {\n\n            if (err) {\n                this._server.logger.info({\n                    err,\n                    tnx: 'autherror',\n                    cid: this._id,\n                    method: 'XOAUTH2',\n                    user: username\n                }, 'Authentication error for %s using %s. %s', username, 'XOAUTH2', err.message);\n                this.send(err.responseCode || 535, err.message);\n                return callback();\n            }\n\n            if (!response.user) {\n                this._server.logger.info({\n                    tnx: 'authfail',\n                    cid: this._id,\n                    method: 'XOAUTH2',\n                    user: username\n                }, 'Authentication failed for %s using %s', username, 'XOAUTH2');\n                this._nextHandler = SASL.XOAUTH2_error.bind(this);\n                this.send(response.responseCode || 334, new Buffer(JSON.stringify(response.data || {})).toString('base64'));\n                return callback();\n            }\n\n            this._server.logger.info({\n                tnx: 'auth',\n                cid: this._id,\n                method: 'XOAUTH2',\n                user: username\n            }, '%s authenticated using %s', username, 'XOAUTH2');\n            this.session.user = response.user;\n            this.session.transmissionType = this._transmissionType();\n\n            this.send(235, 'Authentication successful');\n            callback();\n\n        });\n    },\n\n    XOAUTH2_error(data, callback) {\n        this.send(535, 'Error: Username and Password not accepted');\n        return callback();\n    },\n\n    'CRAM-MD5_token' (canAbort, challenge, token, callback) {\n        token = (token || '').toString().trim();\n\n        if (canAbort && token === '*') {\n            this.send(501, 'Authentication aborted');\n            return callback();\n        }\n\n        let tokenParts = new Buffer(token, 'base64').toString().split(' ');\n        let username = tokenParts.shift();\n        let challengeResponse = (tokenParts.shift() || '').toLowerCase();\n\n        this._server.onAuth({\n            method: 'CRAM-MD5',\n            username,\n            validatePassword(password) {\n                let hmac = crypto.createHmac('md5', password);\n                return hmac.update(challenge).digest('hex').toLowerCase() === challengeResponse;\n            }\n        }, this.session, (err, response) => {\n\n            if (err) {\n                this._server.logger.info({\n                    err,\n                    tnx: 'autherror',\n                    cid: this._id,\n                    method: 'CRAM-MD5',\n                    user: username\n                }, 'Authentication error for %s using %s. %s', username, 'CRAM-MD5', err.message);\n                this.send(err.responseCode || 535, err.message);\n                return callback();\n            }\n\n            if (!response.user) {\n                this._server.logger.info({\n                    tnx: 'authfail',\n                    cid: this._id,\n                    method: 'CRAM-MD5',\n                    user: username\n                }, 'Authentication failed for %s using %s', username, 'CRAM-MD5');\n                this.send(response.responseCode || 535, response.message || 'Error: Authentication credentials invalid');\n                return callback();\n            }\n\n            this._server.logger.info({\n                tnx: 'auth',\n                cid: this._id,\n                method: 'CRAM-MD5',\n                user: username\n            }, '%s authenticated using %s', username, 'CRAM-MD5');\n            this.session.user = response.user;\n            this.session.transmissionType = this._transmissionType();\n\n            this.send(235, 'Authentication successful');\n            callback();\n\n        });\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-smtp-server/node_modules/smtp-server/lib/tls-options.js":"'use strict';\n\n// Expose to the world\nmodule.exports = getTLSOptions;\n\nconst tlsDefaults = {\n    // pregenerated default certificates for localhost\n    // obviusly, do not use in production\n    key: '-----BEGIN RSA PRIVATE KEY-----\\n' +\n        'MIIEpAIBAAKCAQEA6Z5Qqhw+oWfhtEiMHE32Ht94mwTBpAfjt3vPpX8M7DMCTwHs\\n' +\n        '1xcXvQ4lQ3rwreDTOWdoJeEEy7gMxXqH0jw0WfBx+8IIJU69xstOyT7FRFDvA1yT\\n' +\n        'RXY2yt9K5s6SKken/ebMfmZR+03ND4UFsDzkz0FfgcjrkXmrMF5Eh5UXX/+9YHeU\\n' +\n        'xlp0gMAt+/SumSmgCaysxZLjLpd4uXz+X+JVxsk1ACg1NoEO7lWJC/3WBP7MIcu2\\n' +\n        'wVsMd2XegLT0gWYfT1/jsIH64U/mS/SVXC9QhxMl9Yfko2kx1OiYhDxhHs75RJZh\\n' +\n        'rNRxgfiwgSb50Gw4NAQaDIxr/DJPdLhgnpY6UQIDAQABAoIBAE+tfzWFjJbgJ0ql\\n' +\n        's6Ozs020Sh4U8TZQuonJ4HhBbNbiTtdDgNObPK1uNadeNtgW5fOeIRdKN6iDjVeN\\n' +\n        'AuXhQrmqGDYVZ1HSGUfD74sTrZQvRlWPLWtzdhybK6Css41YAyPFo9k4bJ2ZW2b/\\n' +\n        'p4EEQ8WsNja9oBpttMU6YYUchGxo1gujN8hmfDdXUQx3k5Xwx4KA68dveJ8GasIt\\n' +\n        'd+0Jd/FVwCyyx8HTiF1FF8QZYQeAXxbXJgLBuCsMQJghlcpBEzWkscBR3Ap1U0Zi\\n' +\n        '4oat8wrPZGCblaA6rNkRUVbc/+Vw0stnuJ/BLHbPxyBs6w495yBSjBqUWZMvljNz\\n' +\n        'm9/aK0ECgYEA9oVIVAd0enjSVIyAZNbw11ElidzdtBkeIJdsxqhmXzeIFZbB39Gd\\n' +\n        'bjtAVclVbq5mLsI1j22ER2rHA4Ygkn6vlLghK3ZMPxZa57oJtmL3oP0RvOjE4zRV\\n' +\n        'dzKexNGo9gU/x9SQbuyOmuauvAYhXZxeLpv+lEfsZTqqrvPUGeBiEQcCgYEA8poG\\n' +\n        'WVnykWuTmCe0bMmvYDsWpAEiZnFLDaKcSbz3O7RMGbPy1cypmqSinIYUpURBT/WY\\n' +\n        'wVPAGtjkuTXtd1Cy58m7PqziB7NNWMcsMGj+lWrTPZ6hCHIBcAImKEPpd+Y9vGJX\\n' +\n        'oatFJguqAGOz7rigBq6iPfeQOCWpmprNAuah++cCgYB1gcybOT59TnA7mwlsh8Qf\\n' +\n        'bm+tSllnin2A3Y0dGJJLmsXEPKtHS7x2Gcot2h1d98V/TlWHe5WNEUmx1VJbYgXB\\n' +\n        'pw8wj2ACxl4ojNYqWPxegaLd4DpRbtW6Tqe9e47FTnU7hIggR6QmFAWAXI+09l8y\\n' +\n        'amssNShqjE9lu5YDi6BTKwKBgQCuIlKGViLfsKjrYSyHnajNWPxiUhIgGBf4PI0T\\n' +\n        '/Jg1ea/aDykxv0rKHnw9/5vYGIsM2st/kR7l5mMecg/2Qa145HsLfMptHo1ZOPWF\\n' +\n        '9gcuttPTegY6aqKPhGthIYX2MwSDMM+X0ri6m0q2JtqjclAjG7yG4CjbtGTt/UlE\\n' +\n        'WMlSZwKBgQDslGeLUnkW0bsV5EG3AKRUyPKz/6DVNuxaIRRhOeWVKV101claqXAT\\n' +\n        'wXOpdKrvkjZbT4AzcNrlGtRl3l7dEVXTu+dN7/ZieJRu7zaStlAQZkIyP9O3DdQ3\\n' +\n        'rIcetQpfrJ1cAqz6Ng0pD0mh77vQ13WG1BBmDFa2A9BuzLoBituf4g==\\n' +\n        '-----END RSA PRIVATE KEY-----',\n    cert: '-----BEGIN CERTIFICATE-----\\n' +\n        'MIICpDCCAYwCCQCuVLVKVTXnAjANBgkqhkiG9w0BAQsFADAUMRIwEAYDVQQDEwls\\n' +\n        'b2NhbGhvc3QwHhcNMTUwMjEyMTEzMjU4WhcNMjUwMjA5MTEzMjU4WjAUMRIwEAYD\\n' +\n        'VQQDEwlsb2NhbGhvc3QwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDp\\n' +\n        'nlCqHD6hZ+G0SIwcTfYe33ibBMGkB+O3e8+lfwzsMwJPAezXFxe9DiVDevCt4NM5\\n' +\n        'Z2gl4QTLuAzFeofSPDRZ8HH7wgglTr3Gy07JPsVEUO8DXJNFdjbK30rmzpIqR6f9\\n' +\n        '5sx+ZlH7Tc0PhQWwPOTPQV+ByOuReaswXkSHlRdf/71gd5TGWnSAwC379K6ZKaAJ\\n' +\n        'rKzFkuMul3i5fP5f4lXGyTUAKDU2gQ7uVYkL/dYE/swhy7bBWwx3Zd6AtPSBZh9P\\n' +\n        'X+OwgfrhT+ZL9JVcL1CHEyX1h+SjaTHU6JiEPGEezvlElmGs1HGB+LCBJvnQbDg0\\n' +\n        'BBoMjGv8Mk90uGCeljpRAgMBAAEwDQYJKoZIhvcNAQELBQADggEBABXm8GPdY0sc\\n' +\n        'mMUFlgDqFzcevjdGDce0QfboR+M7WDdm512Jz2SbRTgZD/4na42ThODOZz9z1AcM\\n' +\n        'zLgx2ZNZzVhBz0odCU4JVhOCEks/OzSyKeGwjIb4JAY7dh+Kju1+6MNfQJ4r1Hza\\n' +\n        'SVXH0+JlpJDaJ73NQ2JyfqELmJ1mTcptkA/N6rQWhlzycTBSlfogwf9xawgVPATP\\n' +\n        '4AuwgjHl12JI2HVVs1gu65Y3slvaHRCr0B4+Kg1GYNLLcbFcK+NEHrHmPxy9TnTh\\n' +\n        'Zwp1dsNQU+Xkylz8IUANWSLHYZOMtN2e5SKIdwTtl5C8YxveuY8YKb1gDExnMraT\\n' +\n        'VGXQDqPleug=\\n' +\n        '-----END CERTIFICATE-----',\n    // default iojs cipher set, copied from https://certsimple.com/blog/a-plus-node-js-ssl\n    // use defaults provided by nodejs/iojs\n    /*\n    ciphers: [\n        'ECDHE-RSA-AES256-SHA384',\n        'DHE-RSA-AES256-SHA384',\n        'ECDHE-RSA-AES256-SHA256',\n        'DHE-RSA-AES256-SHA256',\n        'ECDHE-RSA-AES128-SHA256',\n        'DHE-RSA-AES128-SHA256',\n        'HIGH',\n        '!aNULL',\n        '!eNULL',\n        '!EXPORT',\n        '!DES',\n        '!RC4',\n        '!MD5',\n        '!PSK',\n        '!SRP',\n        '!CAMELLIA'\n    ].join(':'),*/\n    honorCipherOrder: true,\n    requestOCSP: false\n};\n\n/**\n * Mixes existing values with the default ones.\n *\n * @param {Object} [opts] TLS options\n * @returns {Object} Object with mixed TLS values\n */\nfunction getTLSOptions(opts) {\n    let result = {};\n\n    opts = opts || {};\n\n    Object.keys(opts).forEach(key => result[key] = opts[key]);\n\n    Object.keys(tlsDefaults).forEach(key => {\n        if (!(key in result)) {\n            result[key] = tlsDefaults[key];\n        }\n    });\n\n    return result;\n}\n","/home/travis/build/npmtest/node-npmtest-smtp-server/node_modules/smtp-server/Gruntfile.js":"'use strict';\n\nmodule.exports = function (grunt) {\n\n    // Project configuration.\n    grunt.initConfig({\n        eslint: {\n            all: ['lib/*.js', 'test/*.js', 'examples/*.js', 'Gruntfile.js']\n        },\n\n        mochaTest: {\n            all: {\n                options: {\n                    reporter: 'spec'\n                },\n                src: ['test/*-test.js']\n            }\n        }\n    });\n\n    // Load the plugin(s)\n    grunt.loadNpmTasks('grunt-eslint');\n    grunt.loadNpmTasks('grunt-mocha-test');\n\n    // Tasks\n    grunt.registerTask('default', ['eslint', 'mochaTest']);\n};\n"}